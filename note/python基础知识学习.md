# python基础知识学习

## 基础语法易混

Python 通常是一行写完一条语句，但如果语句很长，我们可以使用**反斜杠**来实现多行语句，在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 

Python 可以在同一行中使用多条语句，语句之间使用分号 **;**

缩进相同的一组语句构成一个代码块，我们称之代码组。像if、while、def和class这样的复合语句，首行以关键字开始，以冒号  **:**  结束，该行之后的一行或多行代码构成代码组。我们将首行及后面的代码组称为一个子句(clause)。

**print** 默认输出是换行的，如果要实现不换行需要在变量末尾加上 `end=""`

(**""**里面可以有空格)

在 python 用 **import** 或者 **from...import** 来导入相应的模块。

代码 **a, b = b, a+b** 的计算方式为先计算右边表达式，然后同时赋值给左边

***

**不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；

**可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。



number（数字）：

有int,float,complex,bool

在 Python 中，变量就是变量，它没有类型，我们所说的"类型"是变量所指的内存中对象的类型。

多变量赋值：

a = b = c = 1

a, b, c = 1, 2, "runoob"

Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加，`True == 1、False == 0`会返回 True，但可以通过is 来判断类型,is 比较的是身份，而不是值。

可以通过使用 **del** 语句删除单个或多个对象

一个变量可以通过赋值指向不同类型的对象。

数值的除法包含两个运算符：**/** 返回一个浮点数，**//** 返回一个整数。

复数可以用 **a + bj**，或者 **complex(a,b)** 表示，a，b都是浮点型



在交互模式中，数字运算最后被输出的表达式结果被赋值给变量 **_**

***

字符串：

字符串的截取的语法格式如下：

```
变量[头下标:尾下标]
```

索引值以 0 为开始值，-1 为从末尾的开始位置。

print(str[2:5])    # 打印字符串第三到第五个字符**（不包含索引为 s5 的字符）**

加号 **+** 是字符串的连接符， 星号 ***** 表示复制当前字符串，与之结合的数字为复制的次数。

反斜杠 \转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 **r**

反斜杠可以作为续行符，也可以使用 **"""..."""** 或者 **'''...'''** 跨越多行

Python 字符串不能被改变

字符串可以格式化：[字符串格式化](“https://www.runoob.com/python3/python3-string.html”) 例子：print ("我叫 %s 今年 %d 岁!" % ('小明', 10))

三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。（所见即所得）

**f-string** 格式化字符串以 **f** 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去

[字符串内建函数](“https://www.runoob.com/python3/python3-string.html”) 

常用函数：

replace(old, new[, max])   # 替换

split(str, num)   # 如果第二个参数 num 有指定值，则分割为 num+1 个子字符串。

strip(chars):去除字符串首尾指定字符



***

bool（布尔类型）:

布尔类型即 True 或 False。

bool 是 int 的子类，因此布尔值可以被看作整数来使用，其中 True 等价于 1。

布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not。

布尔类型也可以被转换成其他数据类型，比如整数、浮点数和字符串。在转换时，True 会被转换成 1，False 会被转换成 0

可以使用 `bool()` 函数将其他类型的值转换为布尔值。以下值在转换为布尔值时为 `False`：`None`、`False`、零 (`0`、`0.0`、`0j`)、空序列（如 `''`、`()`、`[]`）和空映射（如 `{}`）。其他所有值转换为布尔值时均为 `True`。

***

List（列表）：

列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（即嵌套），写在方括号 **[]** 之间、用逗号分隔开；和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。

与Python字符串不一样的是，列表中的元素是可以改变的

可以使用 append() 方法来添加列表项:

```
list1 = ['Google', 'Runoob', 'Taobao']
list1.append('Baidu')
```

可以使用 del 语句来删除列表中的元素

常用函数：

sort()函数：原地升序



***

Tuple（元组）：

与列表类似，不同之处在于**元组的元素不能修改**。元组写在小括号 **()** 里，元素之间用逗号隔开。

元组中的元素类型也可以不相同。可以被索引，截取。

虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。

构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：

```
tup1 = ()    # 空元组
tup2 = (20,) # 一个元素，需要在元素后添加逗号
```



***

Set（集合）：

**无序、可变**的数据类型，元素不会重复，使用大括号 **{}** 表示，元素之间用逗号 **,** 分隔。也可以使用 **set()** 函数创建集合。**注意：**创建一个空集合必须用 **set()** 而不是 { }，因为 **{ }** 是用来创建一个空字典。

a - b 集合a包含而集合b不包含的元素

a | b集合a或b中包含的所有元素

a & b集合a和b中都包含了的元素

a ^ b不同时包含于a和b的元素

添加元素：s.add( x ) 或者 s.update( x )   x可以有多个，逗号隔开

移除元素:s.remove( x ) 或者 s.discard( x )

随机删除：s.pop()       清除：s.clear()

***

Dictionary（字典）：

列表是有序的对象集合，字典是**无序**的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。

字典是一种映射类型，用 **{ }** 标识，它是一个无序的 **键(key) : 值(value)** 的集合。

字典的关键字必须为不可变类型，且不能重复。键可以用数字，字符串或元组充当

创建空字典使用 **{ }**。

访问字典里的值 : 把相应的键放入到方括号中，如 : print ("tinydict['Name']: ", tinydict['Name'])

del tinydict['Name']   # 删除键 'Name'

 tinydict.clear()     # 清空字典 

del tinydict         # 删除字典

常用函数：

dict.get(key)  得到指定键的值

获取值最大对应的键：max(dicts, key=dicts.get)







***

bytes 类型：

不可变的二进制序列，元素是整数值（0 到 255 之间的整数）。

创建 bytes 对象的方式有多种，最常见的方式是使用 b 前缀：

使用 bytes() 函数将其他类型的对象转换为 bytes 类型。bytes() 函数的第一个参数是要转换的对象，第二个参数是编码方式，如果省略第二个参数，则默认使用 UTF-8 编码：

```
x = bytes("hello", encoding="utf-8")
```

***

位运算符：&(按位与)    |（按位或） ^(按位异或)    ~(按位取反）  <<(左移动)    >>（右移动）

逻辑运算符：

Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:

| 运算符 | 逻辑表达式 | 描述                                                         | 实例                    |
| :----- | :--------- | :----------------------------------------------------------- | :---------------------- |
| and    | x and y    | 布尔"与" - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。 | (a and b) 返回 20。     |
| or     | x or y     | 布尔"或" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 | (a or b) 返回 10。      |
| not    | not x      | 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 | not(a and b) 返回 False |

身份运算符：

用于比较两个对象的存储单元

*is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等*



***

用来查询变量所指的对象类型：
`type`:不会认为子类是一种父类类型
`isinstance`:会认为子类是一种父类类型

ord() 函数：用于将字符转换为相应的整数值

range()函数：(start, end[, step])     不包括end

常用方法：

去重：利用set()

修改元组元素：转换为list

可以结合 range() 和 len() 函数以遍历一个序列的索引



***

条件控制：

if语句的关键字为：**if – elif – else**   ；每个条件后面要使用冒号 **:**  

Python3.10 版本添加了 **match...case**

循环：

while ，for ，没有do-while

可以通过设置条件表达式永远不为 false 来实现无限循环，使用 **CTRL+C** 来退出当前的无限循环。

while 循环使用 else 语句：如果 while 后面的条件语句为 false 时，则执行 else 的语句块。

循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，**但循环被 break 终止时不执行**。

pass语句不做任何事情，一般用做占位语句。

for 循环可以遍历任何可迭代对象

***

推导式：

列表推导式：

```
[表达式 for 变量 in 列表] 
[out_exp_res for out_exp in input_list]
或者 
[表达式 for 变量 in 列表 if 条件]
[out_exp_res for out_exp in input_list if condition]
```

- out_exp_res：列表生成元素表达式，可以是有返回值的函数。

- for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。
- if condition：条件语句，可以过滤列表中不符合条件的值。

字典推导式：

```
{ key_expr: value_expr for value in collection }
或
{ key_expr: value_expr for value in collection if condition }
```

集合推导式：

```
{ expression for item in Sequence }
或
{ expression for item in Sequence if conditional }
```

元组推导式：（生成器表达式）

```
(expression for item in Sequence )
或
(expression for item in Sequence if conditional )
```

返回的结果是一个生成器对象。

***

迭代器和生成器：


***

函数：

```
def 函数名（参数列表）:
    函数体
```

不带表达式的 return 相当于返回 None

python 函数的参数传递：

- **传不可变对象：**如整数、字符串、元组。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。
- **传可变对象：**如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响

以下是调用函数时可使用的正式参数类型：

- 必需参数
- 关键字参数

```
def printme( str ):
、、、
printme( str = "菜鸟教程")
```

- 默认参数

```
def printinfo( name, age = 35 ):
```

- 不定长参数

```
def printinfo( arg1, *vartuple ):
```

加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数

加了两个星号 ** 的参数会以字典的形式导入

函数声明时，如果单独出现星号 *****，则星号 ***** 后的参数必须用关键字传入：

```
def f(a,b,*,c):
...
f(1,2,3)   # 报错
f(1,2,c=3) # 正常
```

lambda 匿名函数：

通常在需要函数作为参数传递的情况下使用，例如在 map()、filter()、reduce() 等函数中。

没有函数名称，只能通过赋值给变量或作为参数传递给其他函数来使用。

lambda 语法格式：

```
lambda arguments: expression
```

- `lambda`是 Python 的关键字，用于定义 lambda 函数。
- `arguments` 是参数列表，可以包含零个或多个参数，参数使用逗号 **,** 隔开，但必须在冒号(`:`)前指定。
- `expression` 是一个表达式，用于计算并返回函数的结果。

高阶函数：

能够接受函数作为参数，或者能够返回函数作为结果

map(函数, 可迭代对象)：把一个函数依次作用于可迭代对象，返回新的迭代器

filter(判断函数, 可迭代对象)：用一个判断函数筛选可迭代对象的元素，只保留判断结果为True的元素，返回一个迭代器

Python3.8 新增了一个函数形参语法 / 用来指明（`/`之前的）函数形参必须使用指定位置参数，不能使用关键字参数的形式。

偏函数:

预先设置好一部分参数的函数

```
from functools import partial

def func(a, b):
、、、
pian = partial(func, b = x)
```

闭包：

外层函数里定义内层函数

内层函数引用外层函数的局部变量

外层函数返回内层函数

***

异常捕捉:
可以使用 **try/except** 语句。

- 首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。
- 如果没有异常发生，忽略 except 子句，try 子句执行后结束。
- 如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。
- 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。

一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组

最后一个except子句可以忽略异常的名称，它将被当作通配符使用。可以使用这种方法打印一个错误信息，然后再次把异常抛出。

```
try:
、、、
except  、、:
、、、
except  、、:
、、、
except:
、、、
raise
```

















